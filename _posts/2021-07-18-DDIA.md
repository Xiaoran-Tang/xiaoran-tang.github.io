---
layout:             post
title:              DDIA读书笔记
subtitle:           系统设计
date:      	        2021-07-18
author:             Xiaoran
header-img:     img/post-bg-miui6.jpg
catalog: 	         true
tags:
        - 读书笔记
---
>本书中文名《数据密集型应用系统设计》，英文名《Designing Data-Intensive Applications》

# 第零部分 走进数据系统 

## 第1章 整体设计目标和策略

“数据密集系统”相对与“计算密集系统”的主要区别是，系统的瓶颈不在于CPU的处理能力，而是数据量、数据的复杂度及数据的快速多变性。

### 1.1 认识数据系统

我们一般模块化的使用各个工具，比如数据库、缓存、索引、消息队列。通过集成一个个较小的通用模块，我们可以构建一个专门的数据系统（应用或服务），并且通过界面或API来隐藏内部的实现细节。这样的集成数据系统应该提供的技术保证：可靠，可扩展，可维护

### 1.2 可靠

即使出现故障（硬件、软件、人为失误），也能保持系统正常运转。

### 1.3 可扩展

即使系统的负载增加，也能保持系统性能稳定。

- 负载主要通过读写量来描述，比如推特平均每秒20万笔1KB写入
- 负载影响性能指标，后者最好用百分位数表示，如p99
  - 这方便我们了解异常值有多糟糕，理解整体用户的服务体验
  - 常见的服务标准是，“99%请求的相应时间小于1秒”

### 1.4 可维护

即使系统变得复杂或古老，也容易开发与维护。

- 复杂度包括：状态空间的膨胀，相互依赖关系，不一致的命名，临时修补
- 如何降低复杂度：用设计抽象隐藏大量的实现细节，对外提供干净、易懂的接口

# 第一部分 数据系统的基石

**单台机器的数据系统设计**

数据的建模与查询、存储机制、编码与传输

## 第2章 数据模型与查询语言

大多数应用程序就是多层数据模型的叠加，每层都通过一个简洁的数据模型来隐藏下层的复杂性。这些抽象机制使得不同的人群可以高效协作。

### 2.1 数据模型

数据模型起源于层次模型，之后关系模型是最流行的，后又演化出文档模型、图状模型和键值对模型

- **关系模型**：以SQL为代表
  - 每一行记录为“关系”，是多个字段的无序集合
  - 每个表包含多行记录，自动支持多对多关系
  - 提前定义schema，类似编译时类型检查
  - 将数据库的内部实现细节隐藏在简洁的接口后面
  - 编程语言中的“对象”可能难以直接转换为SQL中的“关系”
- **文档模型**：以JSON和XML为代表
  - 有向树，自包含，无需提前定义schema
  - 依赖应用程序解释其结构和内容
  - 局部性：把相关数据归为一组进行存储
    - 有时关系模型的局部性会带来更好的性能（比如：淘宝秒杀）
    - 类似的实现有：Redis的键值对模型，Cassandra和HBase中的列式存储
  - 有些较新的SQL也支持JSON或文档化数据类型
  - 不适合多对一的关系（比如：许多人生活在一个城市）
    - 因为难以规范化，出现数据不一致
    - 若支持，则代码复杂，性能更差
  - JSON在Web API中非常流行
- 网状模型
  - 已濒危，本身是文件模型/层次模型的推广
  - 记录之间靠指针链接，而不是外键
  - 类似层次模型，更新查询需要修改大量“访问路径”相关的代码
    - 相比之下，SQL的通用查询优化器可以自动生成“访问路径”

### 2.2 数据查询语言

- **声明式**查询语言
  - 比如：SQL、关系代数（集合运算）、CSS、GraphQL、EntQL
  - 语言无需给出中间过程
    - 只需给定输出的数据schema和结果应满足的条件
    - 由查询优化器来决定查询的语句和执行的顺序
  - 隐藏了数据库引擎的实现细节
    - 在不改变查询语句的情况下提高性能
- **命令式**查询语言
  - 比如：大多数编程语言的for循环
  - 语言把执行操作的特定顺序告诉计算机
    - 代码可以逐行遍历，可以推算出中间变量和逻辑判断
    - 限制了多核及多节点上并行执行的能力
- MapReduce介于两者之间（比如：MongoDB）
  - 基于函数式编程语言中的`map`和`reduce`函数
  - 语法有点像λ函数
  - 可以是SQL的一种底层实现

### 2.3 图状模型

- 相比关系模型，文档模型的假设是文档之间的关联很少，而图状模型的假设是所有数据都可能相互关联
- 由顶点（实体）和边构成
  - 边可以连接不同类型的顶点（比如：用户-点赞-帖子）
  - 每个顶点包括：ID、出边的集合、入边的集合、属性的集合（键值对）
  - 每条边包括：ID、起点顶点、终点顶点、边的类型标签、属性的集合（键值对）
- 在存储层面，此模型可在SQL中由顶点关系表和边关系表实现
  - 其中出入边的集合可以通过边关系表来构建二级索引
  - 通过出入边，顶点链条支持任意方向的遍历
- 在查询语言层面，有很多声明式语言，比如Cypher、SPARQL
  - 支持正则表达式，递归地在图中搜索目标

## 第3章 存储与检索

数据库只需做两件事情：更新键值对时，保存；查询键时，返回值。

| 属性         | 业务系统                         | 分析系统                                 |
| ------------ | -------------------------------- | ---------------------------------------- |
| 读特征       | 查询少量键，返回少量记录         | 对大量记录进行汇总（如计数、求和、均值） |
| 写特征       | 随机访问，低延迟写入用户的输入   | 批量导入/ETL或事件流                     |
| 典型使用场景 | 终端用户通过网络应用程序进行交互 | 内部分析师，为决策提供支撑               |
| 数据内容     | 最新/当前的数据状态              | 所有事件的历史数据                       |
| 查询瓶颈     | 硬盘寻道时间                     | 硬盘内存带宽                             |

### 3.1 业务系统：日志与索引

- 定义：**日志**是一个仅支持追加式更新的数据文件
- 最简单的数据库是纯文本日志存储
  - 写入时：在文档末尾追加新的键值对
  - 读出时：遍历全文，返回键最后一次对应的值，复杂度为O(n)
- 定义：**索引**是用来保存键的数据结构，用来优化查询速度
  - 副作用是减慢写入速度，所以只应给有限的字段加索引
- **内存哈希索引**+日志段
  - 使用日志存储：键是数据的键，值是数据值在硬盘中的字节偏移量
  - 无限追加，如何避免硬盘空间耗尽？
    - 将数据依次存成数据段，每个段包含索引和值
    - 当段数超过某上限时，将多个段合并压缩为新段写入
      - 压缩：丢弃日志中重复的键，只保留最新的键值
  - 如何删除键？写入的值为某个特殊的删除字符，压缩时删除键
  - 优势：
    - 读数据时只需一次硬盘读
    - 硬盘顺序写：写入超快（随机写的200倍），不会碎片化
    - 单线程写，数据不可变，保证安全的多线程读
  - 劣势：所有哈希表必须全部放入内存、区间查询效率低：O(n)
- **SSTable**/LSM-Tree
  - 应用于谷歌的LevelDB和脸书的RocksDB
  - 相比上述基础索引，SSTable规定索引中的键必须有序
    - 由平衡树来实现，例如红黑树
  - 内存中的索引只保存少数键，每个键指向（多个段压缩成的）硬盘数据块
    - 存储：键值对直接写入内存树；若内存树过大，将子树追加式地存入硬盘
      - 后台对SSTable进行分层，并周期性地压缩与合并
    - 读取：先试图在内存树中查找某键，找不到则去硬盘逐层寻找
  - 优势：键的数据量和段文件都可大于可用内存、高速写入、区间查询
- **B-tree索引**
  - 最广泛使用，关系数据库的标准索引实现
  - 整个表的索引：平衡树
    - 使用4KB的页作为读写的最小单元，不同于日志结构索引中可变长度的段
    - 每个页包含多个指针，分别引用下一级的页，每级引用都大大缩小键的范围
    - 写入新键时，满的页将分裂为两个半满的页，并更新父页
  - 写入时，原地修改硬盘上的旧页，不同于日志结构索引中仅追加更新
    - 为防止多线程写，编辑树的时候要加互斥锁
    - 为了在崩溃后修复数据，数据先写入预写日志，再编辑树
  - 优势：高速读取、读写性能稳定、键级别的事务隔离
  - 劣势：树的平衡需要更多次硬盘写、硬盘碎片化
- 其他索引概念
  - **聚集索引**/一级索引：在索引中直接保存行数据
  - **非聚集索引**/二级索引：在索引中只保存数据的键/引用
    - 目的是高效地执行连接（JOIN）和搜索
  - 覆盖索引：上两者的折中，索引中保存数据的几个字段
  - 多列索引、模糊索引（单词匹配）、内存数据库（无需序列化）

### 3.2 分析系统

- 小公司的数据少，SQL/电子表格就能同时支持业务系统和分析系统的查询
- 大公司的分析系统运行在单独的数据仓库上面
  - 因为分析查询要扫描大量数据集，代价高，损害业务系统的并发性能
  - 周期或连续地从业务系统中提取数据
    - 业务数据可源于多条业务线，比如电商的销售、仓储、快递、门店
    - 提取-转换-清理-加载到数据仓库的过程被称为ETL
- Hadoop分析系统：硬盘分布式计算MapReduce，内存计算Spark，数据仓库Hive，数据流Pig
- 数据模型：**星型模式**
  - 相比（第二章介绍的）业务系统中复杂的数据模型，分析系统的模型非常一致
  - 星型：事实表位于中间，指向众多维度表
  - 事实表：每行表示特定时间发生的事件，比如：某项物品的购买
    - 每列包含属性（如：时间、产品售价）和外链（如：产品ID、客户ID）
  - 维度表：描述事件中的某一个对象的具体信息，比如：产品、店铺、客户
- **列式存储**
  - 主要解决万亿行的事实表的存储，因为维度表通常只有百万行
  - 业务系统一般把一行的所有值彼此相邻，但分析查询一般只访问少数列
  - 列式存储：数据表的每列存成一个文件，各文件的第i项对应数据表的第i行
  - 因为每列具有相同的数据类型和相似的值，列式存储非常适合数据压缩和矩阵计算
    - 排序后的数据压缩更显著
- 聚合：**数据立方体**
  - 在原始数据上，把常用的查询预先计算并保存
    - 因为有时数据仓库需要频繁地查询相同的聚合结果，比如：全国的月度销售额
    - 聚合：求和、计数、均值、最大值、最小值
  - 数据立方体：以原始数据的列作为维度，在多个维度上压缩数据
    - 比如，原始数据有四个维度：日期、地点、产品、网店
    - 每天每个网店的总销售量：对地点和产品进行聚合，生成日期和网点的二维表

## 第4章 编码与演化

- **编码**：庞大的软件需要拆分成模块，模块间的沟通需要彼此兼容的编码协议
- **演化**：各个模块的快速迭代，schema不断更新，会造成多版本共存
  - 典型原因：版本的滚动升级、终端用户的习惯/局限

### 4.1 数据编码格式

- 基本数据格式
  - 内存中由指针维护的**结构**：对象、数组、树、哈希表
  - 硬盘或网络中的连续字节**文件**：JSON、XML、CSV
- 结构与文件相互转换：**编码**（序列化）、**解码**（反序列化、解析）
  - 编程语言自带的编码一般与语言绑定，牺牲了兼容性、安全性、性能
- 最流行的编码：JSON在Web浏览器中内置，XML语法过于冗长
  - 类型模糊：字符串与数字、整数与浮点数、大数字
  - 不原生支持二进制字节序列和schema更新
    - 二进制编码：方便压缩空间、提升解析性能，但牺牲可读性
- schema驱动的二进制编码协议
  - 需要schema来编码任意的数据
  - 静态类型：Thrift由脸书开发，Protocol Buffers由谷歌开发，近乎同时开源
    - `struct Student {1: required i64 id, 2: optional string name}`
    - 协议原生的工具能生成多种编程语言的类，调库就能自动地编码或解码
    - 字段的编码没有字段名（`id`, `name`），只有字段标签（`1`, `2`）和数据类型
    - 兼容新数据：旧代码能够读取新代码写入的数据
      - 新字段添加到schema后，旧代码自动忽略新的字段
      - 新schema只能删除旧schema里可选的（或有默认值的）字段
    - 兼容旧数据：新代码能够读取旧代码写入的数据
      - 添加的每个新字段都必须是可选的（或有默认值）
  - 动态类型：Hadoop Avro基于JSON，适合动态类型数据处理语言（比如：Pig）
    - 无需为编程语言生成代码
    - 编码内容中没有数据类型、字段标签、字段名称
    - schema演化：读模块和写模块在握手时交换彼此的schema
      - 各个schema只能增加或删除具有默认值的字段
      - 收到数据后，读模块只提取其中自己schema存在的字段

### 4.2 数据传递

数据传递：数据从一个进程流向（不共享内存的）另一个进程
- 基于**数据库**的数据传递
  - 使用数据库**查询语言**直接读写，编码与解码的进程彼此独立
  - 不同的进程会有数据库schema版本差异，小心旧代码丢掉新字段
  - 数据比代码更长久：5年前的数据仍然使用原始编码
    - 添加新列时，除非已完成数据迁移，否则建议将旧数据的新列填入空值
- 基于**服务**的数据传递：REST和RPC
  - 使用网络进行进程间通信
    - 服务器通过网络来公开**API**（**服务**），客户端向API发送请求
  - 和数据库的最大区别：服务限制了数据的范围和粒度，封装了数据获取方式
  - 用户终端-客户端：浏览器、手机桌面app
    - 使用HTTP的`GET`和`POST`读写HTML资源（可使用JS的Ajax来包装异步读写）
  - 组织之间-在线服务：后端系统数据交换
    - 比如：OAuth支持的各种在线服务、脸书公开的GraphAPI
    - REST：使用URL来标识网络上的资源
      - 支持所有主流编程语言、平台、浏览器，伴随庞大的工具生态系统
  - 组织内部-微服务/中台：A服务的客户端可以是B服务的服务器
    - 比如：A是数据库，B是业务逻辑层
    - 每个服务由一个团队进行维护，更容易进行部署、演化和维护
    - RPC/远程过程调用：进程发出的“网络服务请求”看上去与“本地函数调用”相同
      - 局限：难以处理请求超时、无法传递指针变量、不同编程语言间数据转换
      - 新一代RPC框架封装了可能失败的异步操作，比如Futures/Promises
- 基于**消息队列**的数据传递
  - 消息队列兼具RPC和数据库的性质
    - 类似RPC：客户端的请求（消息）以低延迟传递到另一个进程
    - 类似数据库：不直接向解码的进程发送消息，而是让消息代理/队列暂存后发送
  - 单向数据流：指定一个队列/主题，多个生产者向其发布消息，多个消费者对其订阅
    - 若想实现RPC的请求响应，消费者可以向另一个主题发布消息，由原生产者订阅
  - 相比RPC的优点：缓冲区避免接收方过载、崩溃自动重试、逻辑上分离发送方与接收方

# 第二部分 分布式数据

**使用多台机器来维护一个数据库的系统设计**

为啥要在多台机器节点上分布数据？

- 扩展性：数据量或读写的负载严重超过了单台机器的处理上限
  - 共享内存/硬盘架构（垂直扩展）中，两倍硬件指标不一定能处理两倍的负载
  - 无共享架构（水平扩展）中，单台运行数据库软件的机器称为节点
    - 由网线进行连接通讯，由软件进行管理
    - 性价比高，可以租用云计算虚拟机进行部署
- 容错、可用性：当部分组件出现故障，冗余组件可以迅速接管，实现系统继续工作
- 降低延迟：在地理上更靠近客户的应用服务，可以更快地完成数据请求

将数据分布在多节点的方式——复制和分区——经常组合使用：

<img src="https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/分区与副本.png" style="zoom:50%;border:2px solid black" align="left"/>

## 第5章 复制

在多个节点上保存相同数据的副本

- 降低访问延迟、提供冗余、提高并行吞吐量
- 本章核心：如何应对持续更改的数据？如何确保副本间的数据一致？

### 5.1 主从复制

- 定义：每个包含完整数据集的一个数据库称为**副本**
  - 可能保存在一个或（第6章分区支持的）多个节点上
- 

### 5.2 多主节点复制
### 5.3 无主节点复制

## 第6章 分区

单个节点无法容纳整个数据集，则拆分成多个较小的子集/分区

提供可扩展性以应对海量查询压力

​        数据分区与数据复制 .................................190
​        键-值数据的分区 ...................................190
​        分区与二级索引 ...................................195
​        分区再平衡 ....................................198
​        请求路由 ..................................202
​        小结 .................................204

## 第7章 事务

​        深入理解事务 ......................................212
​        弱隔离级别 .................................221
​        串行化 ...........................................237
​        小结 ...........................................250

## 第8章 分布式系统的麻烦

​        故障与部分失效 ...............................260
​        不可靠的网络 ..................................262
​        不可靠的时钟 ..................................271
​        知识，真相与谎言 ...............................282
​        小结 ..........................................292

## 第9章 一致性与共识

​        一致性保证 ....................................304
​        可线性化 ........................................305
​        顺序保证 ........................................319
​        分布式事务与共识 .................................330
​        小结 ...............................................349

# 第三部分 衍生数据

**集成多个数据系统：日志、缓存、索引、数据分析**

两大数据类型：

- 记录数据
  - 真实的业务数据，比如用户账号、用户的发帖记录、购买记录
  - 这是数据的权威版本，不同系统间遇到数据差异时以记录数据为准
- 衍生数据
  - 对记录数据进行一次或多次转换后的结果
  - 若衍生数据丢失，可从原始数据源进行重建
    - 比如缓存不命中，则从底层数据库寻找数据
  - 提供良好的查询性能和业务指导

数据类型一般不取决于具体的数据库、存储机制和查询语言，更多依赖于用户的定义和使用方式

## 第10章 批处理

​        使用UNIX工具进行批处理 .............................368
​        MapReduce与分布式文件系统 .........................375
​        超越MapReduce ....................................394
​        小结 ............................................403

## 第11章 流处理

​        发送事件流 .......................................414
​        数据库与流 .......................................424
​        流处理 .........................................435
​        小结 ............................................449

## 第12章 数据系统的未来

​        数据集成 .........................................461
​        分拆数据库 .......................................469
​        端到端的正确性 ....................................484
​        做正确的事情 .......................................500
